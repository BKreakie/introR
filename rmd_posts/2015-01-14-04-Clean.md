---
title: "04 - Clean"
author: Jeffrey W. Hollister
layout: post_page
---
In the last lesson we focused on some basic cleaning operations (subsetting, merging, reshaping, and sumarizing) using base R.  I actually find myself still using these quite a bit.  That being said, I am slowly trying to make the switch to some of the packages that facilitate working with data frames, namely Hadley Wickham's `dplyr` and `reshape`. 

##Quick Links to Exercises and R code
- [Lesson 4 R Code](/gedr/rmd_posts/2015-01-14-04-Clean.R): All the code from this post in an R Script.
- [Exercise 1](#exercise-1): Subsetting the NLA data with `dplyr`
- [Exercise 2](#exercise-2): Merge two NLA data files using `dplyr`
- [Exercise 3](#exercise-3): Using `dplyr` to reshape and modify to get NLA summary stats
- [Exercise 4](#exercise-4): Chain commands together using pipes.

##Lesson Goals
- Better understand data cleaning through use of `dplyr`
- Understand some of the differences between `dplyr` and base R.
- Be able to repeat what we know in base with `dplyr`
- Know what pipes are and why you might want to use them

##What is `dplyr`? 

The package `dplyr` is a fairly new (2014) package that tries to provide easy tools for the most common data manipulation tasks.  It is built to work directly with data frames.  The thinking behind it was largely inspired by the package `plyr` which has been in use for some time but suffered from being slow in some cases.  `dplyr` address this by porting much of the computation to C++.  An additional feature is the ability to work with data stored directly in an external database.  The benefits of doing this are that the data can be managed natively in a relational database, queries can be conducted on that database, and only the results of the query returned.  

This addresses a common problem with R in that all operations are conducted in memory and thus the amount of data you can work with is limited by available memory.  The database connections essentially remove that limitation in that you can have a database of many 100s GB, conduct queries on it directly and pull back just what you need for analysis in R.  There is a lot of great info on `dplyr`.  If you have an interest, i'd encourage you to look more.  The vignettes are particulary good.

- [`dplyr` GitHub repo](https://github.com/hadley/dplyr)
- [CRAN page: vignettes here](http://cran.rstudio.com/web/packages/dplyr/)

##Subsetting in `dplyr`
In base R we used a combination of indexing, indexing with vectors and `subset()` to select out columns and rows.  In `dplyr` this can be done with two functions, `select()` and `filter()`.  Before we start we need to make sure we've got everything installed and loaded.


{% highlight r %}
install.packages("reshape")
{% endhighlight %}



{% highlight text %}
## Installing package into '/home/jhollist/R/i686-pc-linux-gnu-library/3.1'
## (as 'lib' is unspecified)
{% endhighlight %}



{% highlight text %}
## Error in contrib.url(repos, type): trying to use CRAN without setting a mirror
{% endhighlight %}



{% highlight r %}
install.packages("dplyr")
{% endhighlight %}



{% highlight text %}
## Installing package into '/home/jhollist/R/i686-pc-linux-gnu-library/3.1'
## (as 'lib' is unspecified)
{% endhighlight %}



{% highlight text %}
## Error in contrib.url(repos, type): trying to use CRAN without setting a mirror
{% endhighlight %}



{% highlight r %}
library("rehsape")
{% endhighlight %}



{% highlight text %}
## Error in library("rehsape"): there is no package called 'rehsape'
{% endhighlight %}



{% highlight r %}
library("dplyr")
{% endhighlight %}



{% highlight text %}
## 
## Attaching package: 'dplyr'
## 
## The following object is masked from 'package:stats':
## 
##     filter
## 
## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union
{% endhighlight %}

Let's repeat what we did in the previous exercise with base R, but now with `dplyr`.  I think you will find it to be a bit more intuitive.


{% highlight r %}
#First, select some columns
dplyr_sel<-select(iris,Sepal.Length,Petal.Length,Species)
#That's it.  Select one or many columns
#Now select some, like before
dplyr_big_iris<-filter(iris, Petal.Length>=6)
head(dplyr_big_iris)
{% endhighlight %}



{% highlight text %}
##   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
## 1          6.3         3.3          6.0         2.5 virginica
## 2          7.6         3.0          6.6         2.1 virginica
## 3          7.3         2.9          6.3         1.8 virginica
## 4          7.2         3.6          6.1         2.5 virginica
## 5          7.7         3.8          6.7         2.2 virginica
## 6          7.7         2.6          6.9         2.3 virginica
{% endhighlight %}



{% highlight r %}
#Or maybe we want just the sepal widths of the virginica species
virginica_iris<-filter(iris,Species=="virginica")
head(virginica_iris)
{% endhighlight %}



{% highlight text %}
##   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
## 1          6.3         3.3          6.0         2.5 virginica
## 2          5.8         2.7          5.1         1.9 virginica
## 3          7.1         3.0          5.9         2.1 virginica
## 4          6.3         2.9          5.6         1.8 virginica
## 5          6.5         3.0          5.8         2.2 virginica
## 6          7.6         3.0          6.6         2.1 virginica
{% endhighlight %}

But what if I wanted to select and filter?  There are three ways to do this: use intermediate steps, nest functions, or pipes.  With the intermediate steps, you essentially create a temporary data frame and use that as input to the next function.  You can also nest functions (i.e. one function inside of another).  This is handy, but can be difficult to read if too many functions are nested.  The last option, pipes, are a fairly recent addition to R.  Pipes in the unix/linux world are not new and allow you to chain commands together where the output of one command is the input to the next.  This provides a more natural way to read the commands in that they are executed in the way you conceptualize it and make the interpretation of the code a bit easier.  Pipes in `dplyr` look like `%>%`.  Let's try all three with the same analysis.  Select out a subset of columns but for only a single species.


{% highlight r %}
#Intermediate data frames
#Select First: note the order of the output, neat too!
dplyr_big_iris_tmp1<-select(iris,Species,Sepal.Length,Petal.Length)
dplyr_big_iris_tmp<-filter(iris_tmp1,Petal.Length>=6)
{% endhighlight %}



{% highlight text %}
## Error in filter_(.data, .dots = lazyeval::lazy_dots(...)): object 'iris_tmp1' not found
{% endhighlight %}



{% highlight r %}
head(dplyr_big_iris_tmp)
{% endhighlight %}



{% highlight text %}
## Error in head(dplyr_big_iris_tmp): object 'dplyr_big_iris_tmp' not found
{% endhighlight %}



{% highlight r %}
#Nested function
dplyr_big_iris_nest<-filter(select(iris,Species,Sepal.Length,Petal.Length),Species=="virginica")
head(dplyr_big_iris_nest)
{% endhighlight %}



{% highlight text %}
##     Species Sepal.Length Petal.Length
## 1 virginica          6.3          6.0
## 2 virginica          5.8          5.1
## 3 virginica          7.1          5.9
## 4 virginica          6.3          5.6
## 5 virginica          6.5          5.8
## 6 virginica          7.6          6.6
{% endhighlight %}



{% highlight r %}
#Pipes
dplyr_big_iris_pipe<-select(iris,Species,Sepal.Length,Petal.Length) %>%
  filter(Species=="virginica")
head(dplyr_big_iris_pipe)
{% endhighlight %}



{% highlight text %}
##     Species Sepal.Length Petal.Length
## 1 virginica          6.3          6.0
## 2 virginica          5.8          5.1
## 3 virginica          7.1          5.9
## 4 virginica          6.3          5.6
## 5 virginica          6.5          5.8
## 6 virginica          7.6          6.6
{% endhighlight %}

##Exercise 1

##Merging Data

##Exercise 2

##Reshape and Summarize

This is a place where the `reshape` package and the `cast()` function comes in handy.   An example of that might look like:


{% highlight r %}
#Some long from data
long_df<-data.frame(id=c(rep(1,3),rep(2,3),rep(3,3)),
                    variable=rep(c("a","b","c"),3),
                    value=runif(9,1,10))
#cast
reshape::cast(long_df)
{% endhighlight %}



{% highlight text %}
##   id        a        b        c
## 1  1 3.058081 6.289874 5.144004
## 2  2 3.508487 1.628420 4.757838
## 3  3 5.211132 1.911754 5.934868
{% endhighlight %}

I will admit that I don't use the `reshape` package a lot, and `melt()` and `cast()` often feel like magic, but they are useful!

##Exercise 3


